// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and OpenCL
// Version: 2020.1
// Copyright (C) 1986-2020 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

#include "aesl_mux_load_12i32P.h"
#include "AESL_pkg.h"

using namespace std;

namespace ap_rtl {

const sc_logic aesl_mux_load_12i32P::ap_const_logic_1 = sc_dt::Log_1;
const bool aesl_mux_load_12i32P::ap_const_boolean_1 = true;
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_0 = "0000";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_1 = "1";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_2 = "10";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_3 = "11";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_4 = "100";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_5 = "101";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_6 = "110";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_7 = "111";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_8 = "1000";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_9 = "1001";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_A = "1010";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_F = "1111";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_E = "1110";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_D = "1101";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_C = "1100";
const sc_lv<4> aesl_mux_load_12i32P::ap_const_lv4_B = "1011";
const sc_logic aesl_mux_load_12i32P::ap_const_logic_0 = sc_dt::Log_0;

aesl_mux_load_12i32P::aesl_mux_load_12i32P(sc_module_name name) : sc_module(name), mVcdFile(0) {

    SC_METHOD(thread_ap_phi_mux_UnifiedRetVal_phi_fu_141_p24);
    sensitive << ( empty_2 );
    sensitive << ( empty_3 );
    sensitive << ( empty_4 );
    sensitive << ( empty_5 );
    sensitive << ( empty_6 );
    sensitive << ( empty_7 );
    sensitive << ( empty_8 );
    sensitive << ( empty_9 );
    sensitive << ( empty_10 );
    sensitive << ( empty_11 );
    sensitive << ( empty_12 );
    sensitive << ( empty_13 );
    sensitive << ( tmp_read_fu_60_p2 );

    SC_METHOD(thread_ap_ready);

    SC_METHOD(thread_ap_return);
    sensitive << ( ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 );

    SC_METHOD(thread_tmp_read_fu_60_p2);
    sensitive << ( empty );

    static int apTFileNum = 0;
    stringstream apTFilenSS;
    apTFilenSS << "aesl_mux_load_12i32P_sc_trace_" << apTFileNum ++;
    string apTFn = apTFilenSS.str();
    mVcdFile = sc_create_vcd_trace_file(apTFn.c_str());
    mVcdFile->set_time_unit(1, SC_PS);
    if (1) {
#ifdef __HLS_TRACE_LEVEL_PORT_HIER__
    sc_trace(mVcdFile, ap_ready, "(port)ap_ready");
    sc_trace(mVcdFile, empty_2, "(port)empty_2");
    sc_trace(mVcdFile, empty_3, "(port)empty_3");
    sc_trace(mVcdFile, empty_4, "(port)empty_4");
    sc_trace(mVcdFile, empty_5, "(port)empty_5");
    sc_trace(mVcdFile, empty_6, "(port)empty_6");
    sc_trace(mVcdFile, empty_7, "(port)empty_7");
    sc_trace(mVcdFile, empty_8, "(port)empty_8");
    sc_trace(mVcdFile, empty_9, "(port)empty_9");
    sc_trace(mVcdFile, empty_10, "(port)empty_10");
    sc_trace(mVcdFile, empty_11, "(port)empty_11");
    sc_trace(mVcdFile, empty_12, "(port)empty_12");
    sc_trace(mVcdFile, empty_13, "(port)empty_13");
    sc_trace(mVcdFile, empty, "(port)empty");
    sc_trace(mVcdFile, ap_return, "(port)ap_return");
#endif
#ifdef __HLS_TRACE_LEVEL_INT__
    sc_trace(mVcdFile, ap_phi_mux_UnifiedRetVal_phi_fu_141_p24, "ap_phi_mux_UnifiedRetVal_phi_fu_141_p24");
    sc_trace(mVcdFile, tmp_read_fu_60_p2, "tmp_read_fu_60_p2");
#endif

    }
}

aesl_mux_load_12i32P::~aesl_mux_load_12i32P() {
    if (mVcdFile) 
        sc_close_vcd_trace_file(mVcdFile);

}

void aesl_mux_load_12i32P::thread_ap_phi_mux_UnifiedRetVal_phi_fu_141_p24() {
    if (((((esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_F) || 
            esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_E)) || 
           esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_D)) || 
          esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_C)) || 
         esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_B))) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_13.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_A)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_12.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_9)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_11.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_8)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_10.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_7)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_9.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_6)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_8.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_5)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_7.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_4)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_6.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_3)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_5.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_2)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_4.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_1)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_3.read();
    } else if (esl_seteq<1,4,4>(tmp_read_fu_60_p2.read(), ap_const_lv4_0)) {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = empty_2.read();
    } else {
        ap_phi_mux_UnifiedRetVal_phi_fu_141_p24 = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
    }
}

void aesl_mux_load_12i32P::thread_ap_ready() {
    ap_ready = ap_const_logic_1;
}

void aesl_mux_load_12i32P::thread_ap_return() {
    ap_return = ap_phi_mux_UnifiedRetVal_phi_fu_141_p24.read();
}

void aesl_mux_load_12i32P::thread_tmp_read_fu_60_p2() {
    tmp_read_fu_60_p2 = empty.read();
}

}

